## Շարահյուսական վերլուծություն

Բեյսիկ-Փ լեզվի շարահյուսական վերլուծիչն (syntax analyzer) իրականացված է `parser` 
փաթեթի `Parser` դասով։ Նույն `parser` փաթեթում են ներառված նաև բառային վերլուծիչի 
(lexical analyzer) `Scanner` դասը, տերմինալային սիմվոլների `Token` թվարկումը, 
ծրագրի տեքստի լեքսեմի `Lexeme` դասը, ինչպես նաև շարահյուսական սխալների ազդարարման
`ParseError` դասը։

Շարահյուսական վերլուծության արդյունքում կառուցվում է _աբստրակտ քերականական ծառ_, 
որի հանգույցները `engine` փաթեթի դասերի նմուշներն (instance) են (տես 
[Ինտերպրետատորի բաղադրիչները](components.md) բաժինը)։ Եթե վերլուծության ժամանակ 
հայտնաբերվում է որևէ սխալ, ապա այդ մասին ազդարարվում է `ParseError` դասի նմուշի 
միջոցով և վերլուծությունը դադարեցվում է։ (Վերլուծության սխալների մշակման մի ստրատեգիայի 
մասին նկարագրված է Նիկլաուս Վիրտի «Կիմպիլյատորի կառուցումը» գրքում։ Ընթերցողին 
առաջարկում եմ Բեյսիկ-Փ լեզվի շարահյուսական վերլուծիչում իրականացնել այդ մոտեցումը։)


### Բառային վերլուծություն

Շարահյուսական վերլուծիչն իր աշխատանքում օգտագործում է _բառային վերլուծիչը_ (լեքսիկական
անալիզատոր), որպեսզի ծրագրի տեքստից կարդա հերթական _թոքեն-լեքսեմ_ զույգը։ Բառային 
վերլուծիչն իրականացրել եմ `Scanner` դասում։ Դրա կոնստրուկտորը ստանում է վերլուծության 
ենթական տեքստը, իսկ `next()` մեթոդը, ամեն մի կանչի արդյունքում, վերադարձնում է տեքստից 
կարդացած հերթական լեքսեմը՝ `Lexeme` նասի նմուշ։

`Lexeme` դասը իրար է կապում `Token` թվարկումով (enumeration) սահմանված _թոքենն_ 
(`kind` անդամը) ու ծրագրի տեքստից կարդացած հատվածը՝ _լեքսեմը_ (`value` անդամը)։ 
Իսկ `line` անդամը լեքսեմի տողի համարն է ծրագիր տեքստում։

````
public class Lexeme {
    public Token kind = Token.Unknown;
    public String value = null;
    public int line = 0;

    public Lexeme( Token kn, int ps )
    {
        this(kn, null, ps);
    }

    public Lexeme( Token kn, String vl, int ps )
    {
        kind = kn;
        value = vl;
        line = ps;
    }
    // ...
}
````

Շարահյուսական վերլուծության ժամանակ հաճախ պետք է լինում ստուգել, թե արդյոք հերթական
լեքսեմի տիպը (`kind`) տրված թոքեններից որևէ մեկնէ։ Դրա համար նախատեսված է `is()`
վարիադիկ մեթոդը։

````
public class Lexeme {
    // ...
    public boolean is( Token... exps )
    {
        for( Token ex : exps )
            if( kind == ex )
                return true;
        return false;
    }
    // ...
}
````

`Token` թվարկման մեջ հավաքված են Բեյսիկ-Փ լեզվի քերականության տերմինալային սիմվոլների 
անունները։ Դրանք ես խմբավորել եմ ըստ նշանակության (ծառայողական բառեր, գործողություններ 
և այլն)։

````
public enum Token {
    // անծանոթ է 
    Unknown,
     
    // թիվ, տեքստ, իդենտիֆիկատոր
    Number, Text, Identifier,
    
    // ծառայողական բառեր 
    Declare, Function, End, Let, Input, Print, If,
    Then, ElseIf, Else, For, To, Step, While, Call,

    // կետադրական նշաններ
    LeftParen, RightParen, Comma,

    // տրամաբանական գործողությունների անուններ
    Or, And, Not,

    // համեմատման գործողություններ
    Eq, Ne, Gt, Ge, Lt, Le,
    
    // թվաբանական գործողություններ
    Add, Sub, Mul, Div, Power,

    // նոր տողի նիշ, տեքստի ավարտ 
    NewLine, Eos
}

````

### Վերլուծության ռեկուրսիվ վայրէջքի եղանակ


Շարահյուսական վերլուծությունն իրականացրել եմ _ռեկուրսիվ վայրէջքի_ (recursive descent)
եղանակով։ Որպեսզի պարզ լինի, թե ինչպես է կառուցվել ամբողջ Բեյսիկ-Փ լեզվի վերլուծիչը,


Դիտարկենք, օրինակ, թվաբանական արտահայտությունների լեզվի քերականությունը, որտեղ 
տերմինալային սիմվոլներն են `+`, `-`, `*`, `/`, `(`, `)` և `NUMBER`, իսկ ոչ 
տերմինալայինները՝ `Expr`, `Term` և `Factor`։

````
Expr   = Term { ('+'|'-') Term }.
Term   = Factor { ('*'|'/') Factor }.
Factor = '(' Expr ')'
       | NNUMBER.
````

Քերականության ամեն մի ոչ տերմինալային սիմվոլի համար վերլուծիչի ծրագրում նախատեսվում 
է մի պրոցեդուրա, որի մարմինը ձևավորվում է քերականական կանոնի ձախ կողմի անդամների 
շղթայից։ Եթե հերթական սիմվոլը ոչ տերմինալ է, ապա կանչվում է դրան համապատասխան 
պրոցեդուրան։ Եթե տերմինալային սիմվոլ է, ապա բառային անալիզատորից կարդացվում է 
հերթական թոքենը։ Օրինակ, `Expr` ոչ տերմինալը դահմանող կանոնի համար պետք է գրել
հետևյալը.

````
private void parseExpr()
{
    parseTerm();
    while( look == '+' || look == '-' ) {
        look = nextToken();
        parseTerm();
    }
}
````

Իսկ `Term` և `Factor` կանոնների համար պետք է գրել հետևյալ պրոցեդուրաները.

````
private void parseTerm()
{
    parseFactor();
    while( look == '*' || look == '*' ) {
        look = nextToken();
        parseFactor();
    }
}
````

````
private void parseFactor()
{
    if( look == '(' ) {
        look = nextToken();
        parseExpr();
        look = nexToken();
    }
    else if( look == NUMBER )
        look = nextToken();
}
````

`look` սիմվոլը, որը բերված պրոցեդուրաներում օգտագործված է վերլուծության ընթացքը,
ուղղությունը ճշտելու համար, կոչվում է _look a head_, այսինքն սիմվոլ, որով կարելի 
է _առաջ նայել_ և որոշում կայացնել։ 


